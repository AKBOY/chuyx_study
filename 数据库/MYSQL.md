# 范式

关系型数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式（关系型数据中的每一张表是符合一范式）

第一范式：每个属性（字段）不可再分

存在问题：插入异常、删除异常、修改复杂、数据冗余



第二范式：每个属性都完全依赖于一个候选码

存在问题：删除异常、插入异常



第三范式：符合第二范式的前提且不存在传递依赖

存在问题：查询困难



## mysql与oracle的区别

**相同点：**

- 都是关系型数据库
- 都是比较流行的数据库

**不同点：**

- 并发性：并发性是oltp数据库最重要的特性，但并发涉及到资源的获取、共享与锁定。

  ​	myslq主要以表级锁为主，对资源锁定的粒度很大、如果一个session对一个表加锁时间过长、会让其他session无法更此表的数据。

  ​	虽然INNODB引擎可以用行级锁，但是这个锁的机制依赖于表的索引、如果表没有索引、或者sql语句没有使用索引、那么仍然使用表级锁

  ​	oracle使用的是行级锁，对资源锁定的粒度很小，只是锁定sqk需要的资源，并且加锁实在数据库行上、不依赖于索引。索引**oracle对并发性的支持要好很多。**

- 一致性：oracle支持serializable的隔离级别，可以实现最高级别的读一致性，并且oracle是 read commit（读已提交）的隔离级别，每个session提交后其他session才可以看到提交的更改。oracle通过在undo表空间中构造多板块数据块来实现读一致性，每个session查询时，如果对应的数据块发生变化，oracle会在undo表空间中为这个session构造它查询时的旧的数据块。

  mysql没有类似oracle构造的构造多版本数据块的机制，只支持repeatable read（可重复读）的隔离级别。一个session读取数据时，其他session不能更改数据，但可以在表的最后面插入数据。并且session更新数据时，要加上排它锁，其他session无法访问数据。

- 事务

  oracle很早就支持事务，而mysql在innodb存储引擎的行级锁的情况下才支持事务。

- 数据持久性

  oracle保证提交的数据均可恢复，因为oracle把提交的sql操作线写入了在线联机日志文件中，保存到了磁盘上，但是如果出现数据库或主机异常重启，重启的oracle可以靠联机在线日志恢复客户提交的数据。

  mysql默认提交slq语句，但如果更新过程中出现db或主机重启问题，也许会丢失数据

- 事务的提交方式

  mysql是默认自动提交，而oracle默认不自动提交，	需要用户手动提交，需要在sql末尾写commit指令或者在可视化软件中点击commit按钮

- 逻辑备份

  oracle逻辑备份时不锁定数据，且备份的数据是一致的

  mysql逻辑备份是要锁定数据，才能保证备份的数据是一致的，影响业务正常的dml使用

- 热备份

  oracle有成熟的热备工具rman，热备时，不影响用户使用数据库。既是备份的数据库不一致，也可以在恢复时通过归档日志和联机重做日志进行一致的回复

  mysql的myisax的引擎，用mysql自带的mysqlhostcopy热备时，需要给表加读锁，影响dml操作。

  innodb的引擎，它会备份innodb的表和索引，但是不会备份.frm文件。用ibbackup备份时，会有一个日志文件记录备份期间的数据变化。因此可以不用锁表，不影响其他用户使用数据库，但此工具是收费的。

  innobackup是结合ibbackup使用的一个脚本，他会协助对.frm文件的备份。

- sql语句的扩展和灵活性

  mysql对sql语句有很多非常实用且方便的扩展，比如limit功能，insert可以一次插入多行数据，select某些管理数据可以不加form

  oracle在这方面更加稳重

- 复制

  oracle：既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。
  mysql：复制服务器配置简单，但主库出问题时，丛库有可能丢失一定的数据。且需要手工切换丛库到主库。

- 性能诊断

  oracle有各种成熟的性能诊断调优工具，能实现很多自动分析、诊断功能。比如awr、addm、sqltrace、tkproof等
  mysql的诊断调优方法较少，主要有慢查询日志。

- 权限与安全

  mysql的用户与主机有关，感觉没有什么意义，另外更容易被仿冒主机及ip有可乘之机。
  oracle的权限与安全概念比较传统，中规中矩。

- 分区表和分区索引

  oracle的分区表和分区索引功能很成熟，可以提高用户访问db的体验。
  mysql的分区表还不太成熟稳定。

- 管理工具

  oracle有多种成熟的命令行、图形界面、web管理工具，还有很多第三方的管理工具，管理极其方便高效。
  mysql管理工具较少，在linux下的管理工具的安装有时要安装额外的包（phpmyadmin， etc)，有一定复杂性。



# InnoDB和MyIsAM区别

InnoDB是mysql默认使用的数据库引擎（5.5之后）

- 事务：MyISAM不支持事务，INNODB支持事务。
- 数据行锁定：MyISAM不支持行级锁、它是表级锁，INNODB支持行级锁。
- 外键约束：MyISAM不支持外键约束、INNODB支持外键约束。
- 在线热备份：MyISAm不支持在线热备份，INNODB支持在线热备份
- 全文索引：MyISAM支持全文索引（**mysql在5.6.4版本中也开始支持全文索引**）、INNODB不支持全文索引。
- 表空间的大小：myisam表空间较小，innodb的表空间约为Myisam的两倍
  - MYISAM：节约空间，速度较快
  - INNODB：安全性高、事务的处理、支持索引（多表多用户的操作）

> 在物理空间存在的位置
>
> 所有的数据库文件都存在data目录下，一个文件夹对应一个数据库
>
> 本质还是文件的存储。
>
> mysql引擎在物理文件上的区别：
>
> - InnoDB在数据库表中只有一个*.rfm，以及上级目录下的ibdata1文件
> - Myisam对应文件
>   - *.frm---表结构的定义文件
>   - *.MYD----数据文件
>   - *.MYI------索引文件

## Innodb

INNODB是mysql默认的事务型存储引擎，只要在需要它不支持的特性时，才考虑使用其他存储引擎



INNODB采用MVCC来支持高并发，并且实现了四个标准隔离级别（未提交读、读已提交、可重复读、可串行化）。其默认的隔离级别是可重复读，在可重复度的级别下，通过MVCC+Next-Key Locking防止幻读

主索引是聚簇索引时，在索引中保存了数据，从而避免直接读取磁盘，因此对主键查询有很高的性能。

INNODB内部做了很多优化，包括从磁盘读取数据时采用可预测读，能够自动在内存中出那个键hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓存区的。

InnoDB支持真正的在线热备份，Mysql其他的存储引擎不支持在线热备份，要获取一次性视图需要停止对所有表的写入，而在读写混合的场景中，停止写入可能意味着听读取。

## MyIsAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

# 视图

视图是从一个表或者多个表（或视图）导出的表。

它与基本表不一样，是一个虚表。

数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。

# mysql常用命令

desc tableName：展示创建该数据库表的创建语句

## 建立视图

```sql
create view <视图名>[(列名。。。。。)]
as 子查询
```



# 索引

索引是在存储引擎层实现的，而不是在服务器上实现的，所以不同的存储引擎具有不用的索引类型和实现。

## 索引的作用

- 提高索引速度
- 确保数据的一致性
- 可以加速表和表之间的连接、实现表与表之间的参照完整性
- 使用分组和排序字句进行数据检索时，可以显著减少分组和排序的时间

## 分类

### B+树索引

它是mysql大多存储引擎的默认索引类型。

- 因为不再需要进行全局扫描，只需要对树的进行搜索即可，所以查找速度快很多
- 因为B +Tree的有序性，所以除了用于查找，还可以用于排序和分组
- 可以指定多个列作为索引列，多个索引列共同组成键
- 适用于全键值，键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序列的顺序进行查找，则无法适用索引。

INNODB的B+ 树索引分为主索引和辅助索引。主索引的叶子节点data域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法吧数据存在两个不同的地方，索引一张表只能有一个聚簇索引。

辅助索引的叶子节点的data域记录着主键的值，因此在使用辅助索引进行查找时，需要先找到主键值，然后再到主索引中进行查找，这个过程也称之为回表。

### 主键索引

主键：某一个属性可以唯一的标识一条记录

特点：

- 最常见的索引类型
- 确保数据记录的唯一性
- 确定特定数据记录在数据库中的位置

### 哈希索引

哈希索引能以O(1)时间进行查找，但是失去了有序性。

- 无法用于排序和分组。
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

### 空间数据索引

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。

### 唯一索引

作用：避免用一个表中某数据列中的值重复

与主键索引的区别：主键索引只能有一个，唯一索引可以有多个

### 常规索引

作用：快速定位特定数据

注意：

- index与key关键字都可以设置常规索引
- 应加在查询找条件的字段
- 不宜添加太多常规索引，会影响数据的插入、删除和修改操作

```sql
CREATE TABLE `result`(
   -- 省略一些代码
  INDEX/KEY `ind` (`studentNo`,`subjectNo`) -- 创建表时添加  ind是索引名
)

-- 创建后添加
ALTER TABLE `result` ADD INDEX `ind`(`studentNo`,`subjectNo`);
```

### 全文索引

作用：快速定位特定数据，用于查找文本中的关键字，而不是直接比较是否相同

注意：

- 只能用于MyIsAm类型的数据表
- 只能用于char、varchar、text数据列类型
- 适合大型数据库
- 查找条件使用 MATCH AGAINST，而不是普通的 WHERE。
- 全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。
- InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

## 创建方式

```sql
/*
#方法一：创建表时
  　　CREATE TABLE 表名 (
               字段名1 数据类型 [完整性约束条件…],
               字段名2 数据类型 [完整性约束条件…],
               [UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY
               [索引名] (字段名[(长度)] [ASC |DESC])
               );


#方法二：CREATE在已存在的表上创建索引
       CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名
                    ON 表名 (字段名[(长度)] [ASC |DESC]) ;


#方法三：ALTER TABLE在已存在的表上创建索引
       ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX
                            索引名 (字段名[(长度)] [ASC |DESC]) ;
                           
                           
#删除索引：DROP INDEX 索引名 ON 表名字;
#删除主键索引: ALTER TABLE 表名 DROP PRIMARY KEY;


#显示索引信息: SHOW INDEX FROM student;
*/

/*增加全文索引*/
ALTER TABLE `school`.`student` ADD FULLTEXT INDEX `studentname` (`StudentName`);

/*EXPLAIN : 分析SQL语句执行性能*/
EXPLAIN SELECT * FROM student WHERE studentno='1000';

/*使用全文索引*/
-- 全文搜索通过 MATCH() 函数完成。
-- 搜索字符串作为 against() 的参数被给定。搜索以忽略字母大小写的方式执行。对于表中的每个记录行，MATCH() 返回一个相关性值。即，在搜索字符串与记录行在 MATCH() 列表中指定的列的文本之间的相似性尺度。
EXPLAIN SELECT *FROM student WHERE MATCH(studentname) AGAINST('love');

/*
开始之前，先说一下全文索引的版本、存储引擎、数据类型的支持情况

MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；
MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;
只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。
测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。
*/
```

```sql
create [unique|cluster] index 索引名 on 表名(列名[ASC|AESC])
create [单一索引|聚簇索引] index 索引名 on 表名(列名[升序|降序])
```

## 索引准则

- 索引不是越多越好
- 不要经常变动数据加索引
- 小数据量的表建议不加索引
- 索引一般应加在查找条件的字段

## 索引的数据结构

> -- 我们可以在创建上述索引的时候，为其指定索引类型，分两类
> hash类型的索引：查询单条快，范围查询慢
> btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）
>
> -- 不同的存储引擎支持的索引类型也不一样
> InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
> MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
> Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；
> NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；
> Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；

## B+ Tree原理

### 数据结构

B Tree指的是平衡树（Balance Tree），平衡树是一种查找树，并且所有的叶子节点位于同一层

B+ Tree 是B树一种变形，它是基于B Tree 和叶子节点顺序访问指针进行实现，通常用于数据库和操作系统的文件系统中。

B+树有两种类型的节点：内部节点（也称索引节点）和叶子节点，内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存在叶子节点中。

内部节点的key都是按照从小到大的顺序排列，对于内部节点中的一个key，左子树中的所有key都小于它，右子树中所有key都大于它，叶子节点中记录也是按照从小到大的顺序排列的。

每个叶子节点都存在相邻叶子节点的引用![image-20201014153254394](https://raw.githubusercontent.com/AKBOY/chuyx_study/master/resource/images/image-20201014153254394.png)



### 树的常见特性

#### AVL 树

平衡二叉树，一般是用平衡因子差值决定并通过旋转来实现，左右子树树高差不超过1，那么和红黑树比较它是严格的平衡二叉树，平衡条件非常严格（树高差只有1），只要插入或删除不满足上面的条件就要通过旋转来保持平衡。由于旋转是非常耗费时间的。所以 AVL 树适用于插入/删除次数比较少，但查找多的场景。

#### 红黑树

通过对从根节点到叶子节点路径上各个节点的颜色进行约束，确保没有一条路径会比其他路径长2倍，因而是近似平衡的。所以相对于严格要求平衡的AVL树来说，它的旋转保持平衡次数较少。适合，查找少，插入/删除次数多的场景。（现在部分场景使用跳表来替换红黑树，可搜索“为啥 redis 使用跳表(skiplist)而不是使用 red-black？”）

#### B/B+树

多路查找树，出度高，磁盘IO低，一般用于数据库系统中。

#### B+树和红黑树的比较

红黑树等平衡树可以用来实现索引，但是文件系统及数据库系统普遍采用B+ Tree作为索引结构，主要有以下两个原因：

- 磁盘IO次数

  B+树一个节点可以存储多个元素，相对于红黑树的树高更低，磁盘IO次数更少

- 磁盘预读特性

  为了减少磁盘I/O操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道。每次会读取页的整倍数。

  操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。

#### B+树和B树的比较

B + 树的磁盘IO更低

B+树的内部节点并没有指向关键字具体信息的指针。因此其内部节点相对B树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也就越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

B+树的查询效率更加稳定

由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

B+树元素遍历效率高

B 树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的操作（或者说效率太低）。













































